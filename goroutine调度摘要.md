# 调度原理
`goroutine`调度的GPM模型就不赘述了。这里讲讲调度代码执行的环境。操作系统执行调度的关键是栈切换。通过系统调用，在内核态修改`bp/sp`寄存器，从进程栈切换到内核栈，所谓上下文切换。
`golang`没有操作系统内核态权限，是如何模拟这一过程的呢？答案是`g0`协程。每个M都有一个`g0`协程，用于模拟系统调用执行内核代码的机制。代码在`g0`中执行，就可以不影响原来的`g`，
从而达到模拟内核代码的效果。更进一步，通过`mcall`保存环境切换到`g0`进入系统代码，通过`execute -> gogo`恢复环境切换回用户`goroutine`。核心代码在`runtime/asm_amd64.s`中(各平台文件名不同)
